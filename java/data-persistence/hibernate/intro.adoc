= Руководство по Hibernate. Введение.

== Что такое JDBC?

*JDBC* (*Java Database Connectivity*) – это технология, которая обеспечивает доступ *Java API* к реляционным базам данных. Благодаря этому, наши Java-приложения могут выполнять SQL-запросы и взаимодействовать с базами данных (далее – БД), которые поддерживают *SQL*.

*JDBC* является крайне гибкой и позволяет нам писать приложения, которые не зависят от конкретной платформы и могут взаимодействовать с различными *СУБД* без каких либо изменение в программном коде.

Какие плюсы даёт нам *JDBC*:

* Простая и понятная обработка SQL-запросов
* Крайне удобна для небольших приложений
* Простой и понятный синтаксис

Какие минусы *JDBC*:

* Сложно использовать и поддерживать в больших проектах
* Большое количество кода
* Сложно реализовывать концепцию *MVC*

== Что такое ORM (Object Relational Mapping)?

=== Проблема

Когда создается приложение на Java и необходимо сделать так, чтобы приложение получило доступ к информации, которая хранится в БД, нужно понимать крайне важную деталь:

*Существует огромная разница между объектной и реляционной моделью*

*СУБД* даёт нам информацию в табличном формате, в то время, как *Java* даёт нам информацию в виде некоего графа объектов.

Представим, что у нас есть класс `Developer`, который представляет разработчика:

.Класс `Developer.java`
[source, java]
----
public class Developer {
    private int id;
    private String firstName;
    private String lastName;
    private String specialty;
    private String salary;

    public Developer() {
    }

    public Developer(int id, String firstName, String lastName, String specialty, String salary) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.specialty = specialty;
        this.salary = salary;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getSpecialty() {
        return specialty;
    }

    public void setSpecialty(String specialty) {
        this.specialty = specialty;
    }

    public String getSalary() {
        return salary;
    }

    public void setSalary(String salary) {
        this.salary = salary;
    }
}
----

И есть таблица в БД, которая также представляет разработчика:

.Таблица `developer`:
[source, mysql]
----
CREATE TABLE developer (
    developer_id INT NOT NULL AUTO_INCREMENT,
    first_name VARCHAR(50) DEFAULT NULL,
    last_name VARCHAR(50) DEFAULT NULL,
    specialty VARCHAR(50) DEFAULT NULL,
    SALARY INT DEFAULT NULL,
    PRIMARY KEY (developer_id)
);
----

Допустим, что после того, как создан и java-класс и таблица в БД, необходимо изменить БД, тогда сразу же возникает проблема.
К тому же, когда записываются или читаются данные в/из БД, тогда есть 5 проблем, которые связаны с разницей между *объектно-ориентированной моделью* и *реляционной моделью*:

1. *Наследование* +
В реляционной модели нет никакого понятия, похожего на наследование, которое является одним из ключевых принципов ООП.

2. *Идентификация* +
Для БД есть только одна сущность, по которому объект может быть идентифицирован – это *Первичный Ключ* (*Primary Key*). В то время как в *Java* есть такие вещи, как `(entity1 == entity2)` и `(object1.equals(object2))`.

3. *Ассоциации* +
В *Java* используются ссылки на объекты для ассоциации, а в реляционной модели – *Внешний Ключ* (*Foreign Key*).

4. *Доступ* +
В *Java* и в реляционной БД абсолютно разные способы получения доступа к объекту.

5. *Инкапсуляция* +
Крайне часто, при разработке приложений, придется столкнуться с тем, что *объектно-ориентированная модель* имеет больше классов, чем таблиц в БД.

Отсюда возникает проблема: как сделать так, чтобы *Java* приложение получало доступ к БД и могло корректно интерпретировать эту информацию.
Другими словами, нам нужно создать связь между *Объектом* и *реляционной сущностью*, иначе говоря *Объектно-Реляционное-Связывание* или же – *ORM (Object-Relational Mapping)*.

=== Решение

*ORM* – это техника программирования, которая служит для того, чтобы обеспечивать преобразование данных при их обмене между реляционной базой данных и *Java* (ну или других языков программирования).

Так какие же преимущества нам даёт *ORM* в сравнение с *JDBC*?

* Позволяет бизнес-методам обращаться не к БД, а Java-классам
* Ускоряет разработку приложения
* Основан на *JDBC*
* Отделяет SQL-запросы от объектно-ориентированной модели
* Позволяет не думать о реализации БД
* Сущности основаны на бизнес-задачах, а не на структуре БД
* Управление транзакциями

*ORM* состоит из:

* *API*, который реализует базовые операции (СОЗДАНИЕ, ЧТЕНИЕ,  ИЗМЕНЕНИЕ, УДАЛЕНИЕ) объектов-моделей.
* *Средства настройки метаданных связывания*
* *Техники взаимодействия с транзакциями*, которая позволяет реализовать такие функции, как *dirty checking*, *lazy association fetching* и т.д.

А самыми распространёнными ORM фреймворком являются:

* *Hibernate*
* *Java Object-Oriented Querying* (*jOOQ*)
* *MyBatis*
* *EclipseLink*
* *TopLink*
