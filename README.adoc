== Git: советы новичкам – часть 3
image::/ D:\IT\dev\course-java-basics\workshop-git\img\pic1.png

В финальной части нашей серии статей о работе с Git мы продолжим разговор о ветках, рассмотрим особенности работы с
командой push и расскажем, что такое rebase. Первую и вторую статьи серии вы можете прочитать по ссылкам.

=== Глава 16. Откуда взялась ветка?

Набираемся терпения и продолжаем рассматривать разные рабочие ситуации. Если мы сделаем несколько коммитов, а потом
выполним команду fetch (скачаем свежие коммиты, но пока не применим их в рабочий каталог), то увидим немного
сбивающую с толку картину:

Что это ещё за ветка получилась? Мы ведь не создавали никакой ветки. Может её создал кто-то из сотрудников?
Нет, никто её не создавал. Восстановим хронологию событий:

* Сначала мы скачали свежие коммиты. Тогда последним был коммит «2».
* Затем мы сделали коммиты «3» и «4» (но пока не пушили их).
* В это время другие сотрудники запушили в удалённый репозиторий коммиты «5», «6» и «7».
Тогда мы ничего не знали об этом.
* Наконец, мы сделали fetch и увидели то, что на картинке.

В Git каждый коммит хранит ссылку на предыдущий (это и позволяет нам соединять кружки на рисунках; каждый отрезок –
это ссылка на предыдущий коммит). Когда мы сделали коммит «3», для нас последним коммитом был «2» поэтому они соединены.
Но когда на origin кто-то запушил коммит «5», там последним был тоже коммит «2» –  ведь мы свои коммиты «3» и «4» ещё
не запушили, и на origin их не было. А раз так, то для коммита «5» предыдущим тоже выступает коммит «2»,
именно эту связь Git и запомнил.

Итого, разные люди независимо друг от друга поменяли результат коммита «2» – вот и возникла ветка. Кстати, эта ветка
сейчас есть только в нашем локальном репозитории. В origin её пока нет, поскольку коммиты «3» и «4» мы до сих пор
не запушили.

Что дальше? Поскольку мы сделали fetch, а не pull, то скачанные коммиты ещё не применились к нашему рабочему каталогу.
Давайте применим их – для этого выполним merge. Результат представлен на картинке: